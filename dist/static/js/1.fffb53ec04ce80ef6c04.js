webpackJsonp([1],{"0ATw":function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var v=function(){var e=this,t=e.$createElement;e._self._c;return e._m(0,!1,!1)},_=[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("section",[n("h1",[e._v("checklist")]),e._v(" "),n("hr"),e._v(" "),n("h2",[e._v("需求会议checklist")]),e._v(" "),n("ol",[n("li",[e._v("Sketch是否已经提供，没有提供无法评估样式工作量。")]),e._v(" "),n("li",[e._v("样式修改范围确认，功能之外的东西会使用公共模版组件，样式还原度不保证")]),e._v(" "),n("li",[e._v("有无输入框？有则需要提供详细校验规则，异常情况如何显示")]),e._v(" "),n("li",[e._v("h5页面需要支持大字体和超大字体的展示，不应该接受一个表格超过4列")]),e._v(" "),n("li",[e._v("是否有明确的转圈等待机制，文字提示。特别是h5页面可能会有网络很慢的情况，需要完善交互")])]),e._v(" "),n("h2",[e._v("开发流程checklist")]),e._v(" "),n("ol",[n("li",[e._v("需要进行技术评审，包括开会，确定接口，发邮件同步结论")]),e._v(" "),n("li",[e._v("组内评估时间，保证按时保质完成需求。")]),e._v(" "),n("li",[e._v("对需求有疑问且产品同学不能立即回答的，必须要以excel文件进行汇总归档，等待确认。")]),e._v(" "),n("li",[e._v("技术评审会之前，所有的需求及资源均需要完善。最迟要在发技术评审结论邮件之前提供出来。")]),e._v(" "),n("li",[e._v("是否已经指定review范围，review人员。")]),e._v(" "),n("li",[e._v("技术评审流程结束后，禁止任何私下里修改需求。所有对需求的修改，需要同步到前端内部群，同时需要同步到至少“oms”或者“bms”的项目群里面。同步人员涉及：前端开发、后端开发、测试。")])]),e._v(" "),n("h2",[e._v("Review流程checklist")]),e._v(" "),n("ol",[n("li",[e._v("开发时间预留两个规模review，review结果以bug单形式在"),n("code",{pre:!0},[e._v("前端团队量化跟踪")]),e._v("里面跟踪")]),e._v(" "),n("li",[e._v("在提测演示前需要将所有高及以上bug单修改完")]),e._v(" "),n("li",[e._v("上beta前，需要将所有提到的review bug单全部修改完。挂起需要经过允许。")])]),e._v(" "),n("h2",[e._v("Review代码checklist")]),e._v(" "),n("ol",[n("li",[e._v("注释；")]),e._v(" "),n("li",[e._v("缩进；//废除，交给eslint来做")]),e._v(" "),n("li",[e._v("编程规范；")]),e._v(" "),n("li",[e._v("命名规范——蒋健")]),e._v(" "),n("li",[e._v("BEM风格——孙根华")]),e._v(" "),n("li",[e._v("模块化是否合理")]),e._v(" "),n("li",[e._v("代码逻辑是否有漏洞")]),e._v(" "),n("li",[e._v("业务逻辑是否有漏洞")]),e._v(" "),n("li",[e._v("提交接口多次点击要保证不会重复下发")]),e._v(" "),n("li",[e._v("提交接口应该有一定的等待效果，特别是h5页面的网络无法保证")]),e._v(" "),n("li",[e._v("请求接口多次下发的，可能存在第一次调用的接口反而比第二次调用的接口返回慢的情况。需要去除已经失效了的第一次调用结果")]),e._v(" "),n("li",[e._v("vue组件中新增事件监听的，需要考虑vue的生命周期。例如mounted中新增的事件，可能因为vue-router导致该组件多次执行mounted的内容，从而导致内存泄漏。")])]),e._v(" "),n("h2",[e._v("Beta前的checklist")]),e._v(" "),n("ol",[n("li",[e._v("代码review是否已经完成")]),e._v(" "),n("li",[e._v("相关开发留守")]),e._v(" "),n("li",[e._v('代码修改涉及到的库，需要在ops_doc发布文档库中创建对应的系统目录，表示此系统需要发布"ssh://git@192.168.0.22:11022/jacky.liu/ops_doc.git"')]),e._v(" "),n("li",[e._v("3.15.0版本开始，需要提前确认是否已经执行“npm run build”，或者是否已经加入jenkins。")])])])}],o={render:v,staticRenderFns:_},r=o,s=n("/Xao"),p=s(null,r,!1,null,null,null);t.default=p.exports},"0SRW":function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var v=function(){var e=this,t=e.$createElement;e._self._c;return e._m(0,!1,!1)},_=[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("section",[n("p",[e._v("文章B")])])}],o={render:v,staticRenderFns:_},r=o,s=n("/Xao"),p=s(null,r,!1,null,null,null);t.default=p.exports},"9+yl":function(e,t,n){e.exports=n("AM97")},AM97:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var v=function(){var e=this,t=e.$createElement;e._self._c;return e._m(0,!1,!1)},_=[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("section",[n("h1",[n("a",{attrs:{href:"https://vuex.vuejs.org/zh-cn/intro.html"}},[e._v("Vuex")])]),e._v(" "),n("hr"),e._v(" "),n("h2",[e._v("Vuex 是什么？")]),e._v(" "),n("p",[e._v("Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。")]),e._v(" "),n("p",[n("strong",[e._v("注释")]),e._v("：vuex可以类比理解为组件内部的data提升到全局（管理）。")]),e._v(" "),n("div",[n("img",{staticStyle:{width:"700px"},attrs:{src:"https://vuex.vuejs.org/zh-cn/images/vuex.png",alt:"vuex工作原理图",align:"center"}})]),e._v(" "),n("p",[n("strong",[e._v("注释")]),e._v("：Vuex有3个部分组成:State，Mutations，Actions。State是储存数据的核心，驱动应用的数据源；Mutations是修改State的唯一方式，必须是同步操作（后面Mutations会讲到）；Actions通过提交Mutations修改State，可以异步操作，主要用来Ajax请求；components以声明方式将State映射到视图，并且可以做Mutations和Actions的提交。")]),e._v(" "),n("h2",[e._v("为什么使用Vuex")]),e._v(" "),n("p",[e._v("当我们的应用遇到多个组件共享状态时，单向数据流的简洁性很容易被破坏：")]),e._v(" "),n("ul",[n("li",[e._v("多个视图依赖于同一状态")]),e._v(" "),n("li",[e._v("来自不同视图的行为需要变更同一状态 "),n("br"),e._v("\n对于问题一，传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。"),n("br"),e._v("\n对于问题二，我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。")])]),e._v(" "),n("p",[n("strong",[e._v("注释")]),e._v(" 类似"),n("a",{attrs:{href:"https://192.168.0.33/omsv2/oms/report/report_group"}},[e._v("综合报表页面")]),e._v("，如果不用vuex那我们需要给每一个组件层层嵌套的传出对应的数据，这样做第一嵌套组件的数据关联需要比较强，第二非父子组件通信比较吃力，第三后期维护成本较高。")]),e._v(" "),n("h1",[n("a",{attrs:{href:"https://vuex.vuejs.org/zh-cn/state.html"}},[e._v("State")])]),e._v(" "),n("hr"),e._v(" "),n("p",[e._v("State是Vuex的核心，是唯一的数据源，每个应用将仅仅包含一个 store 实例。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照(devtools谷歌调试工具)。")]),e._v(" "),n("h2",[e._v("基础用法")]),e._v(" "),n("p",[e._v("那么我们如何在 Vue 组件中展示状态呢？由于 Vuex 的状态存储是响应式的，从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("// 创建一个 Counter 组件\nconst Counter = {\n  template: `<div>{{ count }}</div>`,\n  computed: {\n    count () {\n      return store.state.count\n    }\n  }\n}\n\n//对于跟组件注入store的模式，在Counter.vue文件内\n\n//...\ncomputed:{\n  count(){\n  \treturn this.$store.state.count\n  }\n}\n//...\n\n")])]),e._v(" "),n("p",[e._v("每当 store.state.count 变化的时候, 都会重新求取计算属性，并且触发更新相关联的 DOM。")]),e._v(" "),n("p",[n("strong",[e._v("注释")]),e._v("：这里为什么不能放在components里的data中，这和js的数据类型附值有关系，如果是基本类型，只是一次简单的附值，而引用类型它们指针指向相同，所以如果在data中附值是基本类型就不能做到响应式")]),e._v(" "),n("h2",[e._v("mapState 辅助函数")]),e._v(" "),n("p",[e._v("当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("// 在单独构建的版本中辅助函数为 Vuex.mapState\n\nimport { mapState } from 'vuex'\n\nexport default {\n  // ...\n  computed: mapState({\n    // 箭头函数可使代码更简练\n    count: state => state.count,\n\n    // 传字符串参数 'count' 等同于 `state => state.count`\n    countAlias: 'count',\n\n    // 为了能够使用 `this` 获取局部状态，必须使用常规函数\n    countPlusLocalState (state) {\n      return state.count + this.localCount\n    }\n  })\n}\n")])]),e._v(" "),n("p",[e._v("当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组。")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("computed: mapState([\n  // 映射 this.count 为 store.state.count\n  'count'\n])\n")])]),e._v(" "),n("p",[n("strong",[e._v("注释")]),e._v("：大部分情况下我们需要组件内部的computed（计算组件data中的相关属性），这时候需要 "),n("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_operator"}},[e._v("对象展开运算符")]),e._v("将多个对象合并为一个，以使我们可以将最终对象传给 computed 属性。")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("computed: {\n  localComputed () { /* ... */ },\n  // 使用对象展开运算符将此对象混入到外部对象中\n  ...mapState({\n    // ...\n  })\n}\n")])]),e._v(" "),n("h1",[n("a",{attrs:{href:"https://vuex.vuejs.org/zh-cn/getters.html"}},[e._v("Getter")])]),e._v(" "),n("hr"),e._v(" "),n("p",[e._v("有时候我们需要从 store 中的 state 中派生出一些状态，getter是对state数据的处理（可以对比理解为组件内部computed对data的计算）")]),e._v(" "),n("h2",[e._v("基础用法")]),e._v(" "),n("p",[e._v("接受两个参数 state,getters，第二个可以省略(Getter 会暴露为 store.getters 对象, 我们可以通过getters获取getters内部的getter如下面的doneTodosCount)")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("const store = new Vuex.Store({\n  state: {\n    todos: [\n      { id: 1, text: '...', done: true },\n      { id: 2, text: '...', done: false }\n    ]\n  },\n  getters: {\n    doneTodos: state => {\n      return state.todos.filter(todo => todo.done)\n    },\n    doneTodosCount: (state, getters) => {\n      return getters.doneTodos.length\n    }\n  }\n})\n\nstore.getters.doneTodosCount // -> 1\n")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("//组件内使用\ncomputed: {\n  doneTodosCount () {\n    return this.$store.getters.doneTodosCount\n  }\n}\n")])]),e._v(" "),n("h2",[e._v("mapGetters 辅助函数")]),e._v(" "),n("p",[e._v("类似mapState "),n("a",{attrs:{href:"https://vuex.vuejs.org/zh-cn/getters.html"}},[e._v("参考官网")])]),e._v(" "),n("h1",[n("a",{attrs:{href:"https://vuex.vuejs.org/zh-cn/mutations.html"}},[e._v("Mutations")])]),e._v(" "),n("hr"),e._v(" "),n("h2",[e._v("基础用法")]),e._v(" "),n("p",[e._v("更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("const store = new Vuex.Store({\n  state: {\n    count: 1\n  },\n  mutations: {\n    increment (state) {\n      // 变更状态\n      state.count++\n    }\n  }\n})\n")])]),e._v(" "),n("p",[e._v("你不能直接调用一个 mutation handler。这个选项更像是事件注册：“当触发一个类型为 increment 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 store.commit 方法：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("store.commit('increment')\n")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("this.$store.commit('increment')\n")])]),e._v(" "),n("p",[n("strong",[e._v("注释")]),e._v("：type用来暴露mutations对象的key值，在组件内部或者action中cmmmit(Mutations的type)，来执行对应的回调函数。")]),e._v(" "),n("h3",[e._v("传参")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("//...参数为字符串\nmutations: {\n  increment (state, n) {\n    state.count += n\n  }\n}\nstore.commit('increment', 10)\n//组件中提交\nthis.$store.commit('increment', 10)\n")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("// 参数为对象\nmutations: {\n  increment (state, payload) {\n    state.count += payload.amount\n  }\n}\nstore.commit('increment', {\n  amount: 10\n})\n//组件中提交\nthis.$store.commit('increment', {\n  amount: 10\n})\n")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("提交 mutation 的另一种方式是直接使用包含 type 属性的对象：\nstore.commit({\n  type: 'increment',\n  amount: 10\n})\n")])]),e._v(" "),n("h2",[e._v("Mutation 需遵守 Vue 的响应规则")]),e._v(" "),n("p",[e._v("既然 Vuex 的 store 中的状态是响应式的，那么当我们变更状态时，监视状态的 Vue 组件也会自动更新。这也意味着 Vuex 中的 mutation 也需要与使用 Vue 一样遵守一些注意事项：")]),e._v(" "),n("ul",[n("li",[e._v("最好提前在你的 store 中初始化好所有所需属性。")]),e._v(" "),n("li",[e._v("当需要在对象上添加新属性时，你应该")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("使用 Vue.set(obj, 'newProp', 123), 或者\n\n以新对象替换老对象。例如，利用 stage-3 的对象展开运算符我们可以这样写：\n\nstate.obj = { ...state.obj, newProp: 123 }\n")])]),e._v(" "),n("h2",[e._v("Mutation 必须是同步函数")]),e._v(" "),n("p",[e._v("一条重要的原则就是要记住 mutation 必须是同步函数。为什么？请参考下面的例子：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("mutations: {\n  someMutation (state) {\n    api.callAsyncMethod(() => {\n      state.count++\n    })\n  }\n}\n")])]),e._v(" "),n("p",[e._v("现在想象，我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志。每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。然而，在上面的例子中 mutation 中的异步函数中的回调让这不可能完成：因为当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的。"),n("br"),e._v(" "),n("strong",[e._v("注释")]),e._v(" mutation提交异步操作也是会成功修改数据，提交mutation时devtools会获取当时state的一次快照，所以如果我们是异步操作的话，获取快照的数据就会存在误差，破毁了数据流。"),n("a",{attrs:{href:"https://www.zhihu.com/question/48759748"}},[e._v("参考地址")])]),e._v(" "),n("h2",[e._v("mapMutations")]),e._v(" "),n("p",[e._v("mapMutations类似mapState具体参考"),n("a",{attrs:{href:"https://vuex.vuejs.org/zh-cn/mutations.html"}},[e._v("vuex官网")])]),e._v(" "),n("h1",[n("a",{attrs:{href:"https://vuex.vuejs.org/zh-cn/actions.html"}},[e._v("Actions")])]),e._v(" "),n("hr"),e._v(" "),n("h2",[e._v("actions是什么")]),e._v(" "),n("p",[e._v("Action 类似于 mutation，不同在于：")]),e._v(" "),n("ul",[n("li",[e._v("Action 提交的是 mutation，而不是直接变更状态。")]),e._v(" "),n("li",[e._v("Action 可以包含任意异步操作。")])]),e._v(" "),n("p",[n("strong",[e._v("注释")]),e._v("：action通常用来做ajax处理")]),e._v(" "),n("h2",[e._v("基础用法")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("const store = new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment (state) {\n      state.count++\n    }\n  },\n  actions: {\n    increment ({commit},payload) {\n    \t//可以异步操作，也可以同步操作\n    \tsetTimeout(function(){\n    \t  console.log(payload)\n\t\t  commit('increment')//注意这里是提交mutation\n    \t},1000)\n    },\n    actionA ({ commit }) {\n     return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        commit('someMutation')\n        resolve()\n      }, 1000)\n     })\n    },\n    actionB ({ dispatch, commit }) {\n     return dispatch('actionA').then(() => {\n      commit('someOtherMutation')\n     })\n    }\n  }\n})\n")])]),e._v(" "),n("p",[n("strong",[e._v("注释")]),e._v("：action有两个参数：（第二个可以省略）")]),e._v(" "),n("ul",[n("li",[e._v("第一个是对象包括当前vuex实例的方法和属性：dispatch（暴露actions），commit（提交mutation），state，getters；")]),e._v(" "),n("li",[e._v("第二个payload是action分发（执行）传过来的参数")])]),e._v(" "),n("h3",[e._v("分发（执行）Action及参数")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("store.dispatch('increment')\n\n//组件内部\nthis.$store.dispatch('increment')\n")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("// 以载荷形式分发\nstore.dispatch('incrementAsync', {\n  amount: 10\n})\n\n// 以对象形式分发\nstore.dispatch({\n  type: 'incrementAsync',\n  amount: 10\n})\n")])]),e._v(" "),n("h3",[e._v("组合 Action(actionA,actionB)的分发（执行）")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("//在分发actionB时，actionB 通过对象参数中的dispatch（暴露actions）会先执行actions中的actionA\nstore.dispatch('actionB')\n\n//组件内部\nthis.$store.dispatch('actionB')\n")])]),e._v(" "),n("h3",[e._v("mapActions")]),e._v(" "),n("p",[e._v("mapActions类似mapState具体参考"),n("a",{attrs:{href:"https://vuex.vuejs.org/zh-cn/actions.html"}},[e._v("vuex官网")])]),e._v(" "),n("h1",[n("a",{attrs:{href:"https://vuex.vuejs.org/zh-cn/modules.html"}},[e._v("Module")])]),e._v(" "),n("hr"),e._v(" "),n("p",[e._v("由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。")]),e._v(" "),n("p",[e._v("为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割。")]),e._v(" "),n("p",[e._v("具体用法参考"),n("a",{attrs:{href:"https://vuex.vuejs.org/zh-cn/modules.html"}},[e._v("官网")])])])}],o={render:v,staticRenderFns:_},r=o,s=n("/Xao"),p=s(null,r,!1,null,null,null);t.default=p.exports},BE8U:function(e,t,n){e.exports=n("Wrms")},FloJ:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var v=function(){var e=this,t=e.$createElement;e._self._c;return e._m(0,!1,!1)},_=[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("section",[n("h1",[e._v("H5侧边栏")]),e._v(" "),n("hr"),e._v(" "),n("h2",[e._v("现状分析")]),e._v(" "),n("p",[e._v("由于目前项目中有三块H5,分别是:")]),e._v(" "),n("ol",[n("li",[e._v("高毅h5")]),e._v(" "),n("li",[e._v("翼虎h5")]),e._v(" "),n("li",[e._v("高毅投研")])]),e._v(" "),n("p",[e._v("开始的做法，是每一块都有一个侧边栏。")]),e._v(" "),n("h2",[e._v("导致问题")]),e._v(" "),n("p",[e._v("当需要改动侧边栏时，需要三处地方分别修改，费事费力。")]),e._v(" "),n("h2",[e._v("处理方式")]),e._v(" "),n("p",[e._v("目前通过 webpack 打包成一个 单独的js文件，供上述三块使用。\n这样就可以实现了，需要改动时，只需要改动一处代码即可。")]),e._v(" "),n("h2",[e._v("使用方式")]),e._v(" "),n("ol",[n("li",[n("p",[e._v("在 "),n("code",{pre:!0},[e._v("/src/webpack_js/components/common/menu-bar-h5")]),e._v(" 对侧边栏组件进行修改")])]),e._v(" "),n("li",[n("p",[e._v("通过命令 "),n("code",{pre:!0},[e._v("npm run menubarh5")]),e._v(" 来打包生成文件")])]),e._v(" "),n("li",[n("p",[e._v("将生成在 "),n("code",{pre:!0},[e._v("/public/js/menu-bar-h5.js")]),e._v(" 和 "),n("code",{pre:!0},[e._v("/public/js/menu-bar-h5.js.map")]),e._v(" 文件上传即可")])])]),e._v(" "),n("h2",[e._v("存在问题")]),e._v(" "),n("p",[e._v("目前基于上面的打包方式的代码，产生了 vue 不能通过 import 方式导入的问题。只能在页面中通过 srcipt 的方式来引入 vue")]),e._v(" "),n("blockquote",[n("p",[e._v("针对这个问题，问问大家有没有什么好的方式")])])])}],o={render:v,staticRenderFns:_},r=o,s=n("/Xao"),p=s(null,r,!1,null,null,null);t.default=p.exports},T5Ww:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var v=function(){var e=this,t=e.$createElement;e._self._c;return e._m(0,!1,!1)},_=[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("section",[n("h2",[e._v("命名规范（建议稿")]),e._v(" "),n("h3",[e._v("组件名为多个单词")]),e._v(" "),n("p",[e._v("例子:")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("Vue.component('todo-item', {\n  // ...\n})\nexport default {\n  name: 'TodoItem',\n  // ...\n}\n\n")])]),e._v(" "),n("h3",[e._v("私有属性名称")]),e._v(" "),n("p",[e._v("在插件、混入等扩展中始终为自定义的私有属性使用 $_ 前缀。并附带一个命名空间以回避和其它作者的冲突 (比如 $"),n("em",[e._v("yourPluginName")]),e._v(")")]),e._v(" "),n("p",[e._v("例子:")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("var myGreatMixin = {\n  // ...\n  methods: {\n    $_myGreatMixin_update: function () {\n      // ...\n    }\n  }\n}\n")])]),e._v(" "),n("h3",[e._v("组件名称")]),e._v(" "),n("p",[e._v("只要有能够拼接文件的构建系统，就把每个组件单独分成文件。")]),e._v(" "),n("p",[e._v("例子:")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("components/\n|- TodoList.js\n|- TodoItem.js\n")])]),e._v(" "),n("p",[e._v("或者")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("components/\n|- TodoList.vue\n|- TodoItem.vue\n")])]),e._v(" "),n("h3",[e._v("单文件组件文件大小写")]),e._v(" "),n("p",[e._v("单词大写开头对于代码编辑器的自动补全最为友好，因为这使得我们在 JS(X) 和模板中引用组件的方式尽可能的一致。然而，混用文件命名方式有的时候会导致大小写不敏感的文件系统的问题，这也是横线连接命名同样完全可取的原因。")]),e._v(" "),n("p",[e._v("例子:")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("components/\n|- MyComponent.vu TodoItem.js\n")])]),e._v(" "),n("h3",[e._v("基础组件名")]),e._v(" "),n("p",[e._v("应用特定样式和约定的基础组件 (也就是展示类的、无逻辑的或无状态的组件) 应该全部以一个特定的前缀开头，比如 Base、App 或 V。\n根据业务需要采用 Xc")]),e._v(" "),n("p",[e._v("例子:")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("components/\n|- XcButton.vue\n|- XcTable.vue\n|- XcIcon.vue\n")])]),e._v(" "),n("h3",[e._v("单例组件名")]),e._v(" "),n("p",[e._v("只应该拥有单个活跃实例的组件应该以 The 前缀命名，以示其唯一性。\n这不意味着组件只可用于一个单页面，而是每个页面只使用一次。这些组件永远不接受任何 prop，因为它们是为你的应用定制的，而不是它们在你的应用中的上下文。如果你发现有必要添加 prop，那就表明这实际上是一个可复用的组件，只是目前在每个页面里只使用一次。")]),e._v(" "),n("p",[e._v("例子:")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("components/\n|- TheWindControlSetting.vue\n|- TheWindControlTest.vue\n|- TheStockPoolSettings.vue\n\n")])]),e._v(" "),n("h3",[e._v("紧密耦合的组件名")]),e._v(" "),n("p",[e._v("如果一个组件只在某个父组件的场景下有意义，这层关系应该体现在其名字上。因为编辑器通常会按字母顺序组织文件，所以这样做可以把相关联的文件排在一起。")]),e._v(" "),n("p",[e._v("例子:")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("components/\n|- TodoList.vue\n|- TodoListItem.vue\n|- TodoListItemButton.vue\n\n")])]),e._v(" "),n("h3",[e._v("组件名中的单词顺序")]),e._v(" "),n("p",[e._v("组件名应该以高级别的 (通常是一般化描述的) 单词开头，以描述性的修饰词结尾。")]),e._v(" "),n("p",[e._v("例子:")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("components/\n|- SearchButtonClear.vue\n|- SearchButtonRun.vue\n|- SearchInputQuery.vue\n|- SearchInputExcludeGlob.vue\n|- SettingsCheckboxTerms.vue\n|- SettingsCheckboxLaunchOnStartup.vue\n")])]),e._v(" "),n("h3",[e._v("自闭合组件")]),e._v(" "),n("p",[e._v("在单文件组件、字符串模板和 JSX 中没有内容的组件应该是自闭合的——但在 DOM 模板里永远不要这样做")]),e._v(" "),n("p",[e._v("自闭合组件表示它们不仅没有内容，而且刻意没有内容。其不同之处就好像书上的一页白纸对比贴有“本页有意留白”标签的白纸。而且没有了额外的闭合标签，你的代码也更简洁。\n不幸的是，HTML 并不支持自闭合的自定义元素——只有官方的“空”元素。所以上述策略仅适用于进入 DOM 之前 Vue 的模板编译器能够触达的地方，然后再产出符合 DOM 规范的 HTML")]),e._v(" "),n("p",[e._v("例子:")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("    \x3c!-- 在单文件组件、字符串模板和 JSX 中 --\x3e\n    <MyComponent/>\n    \x3c!-- 在 DOM 模板中 --\x3e\n    <my-component></my-component>\n")])]),e._v(" "),n("h3",[e._v("js/jsx中的组件名大小写")]),e._v(" "),n("p",[e._v("JS/JSX 中的组件名应该始终是PascalCase的，尽管在较为简单的应用中只使用Vue.component 进行全局组件注册时，可以使用 kebab-case 字符串。\n用Vue.component 进行全局组件注册时，可以使用 kebab-case 字符串")]),e._v(" "),n("p",[e._v("例子:")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("Vue.component('MyComponent', {\n  // ...\n})\nVue.component('my-component', {\n  // ...\n})\nimport MyComponent from './MyComponent.vue'\nexport default {\n  name: 'MyComponent',\n  // ...\n}\n")])]),e._v(" "),n("h3",[e._v("完整单词组件名")]),e._v(" "),n("p",[e._v("组件名应该倾向于完整单词而不是缩写。")]),e._v(" "),n("p",[e._v("例子:")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("components/\n|- StudentDashboardSettings.vue\n|- UserProfileOptions.vue\n\n")])]),e._v(" "),n("h3",[e._v("prop名大小写")]),e._v(" "),n("p",[e._v("在声明 prop 的时候，其命名应该始终使用 camelCase，而在模板和 JSX 中应该始终使用 kebab-case。")]),e._v(" "),n("p",[e._v("例子:")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('props: {\n  greetingText: String\n}\n<WelcomeMessage greeting-text="hi"/>\n')])]),e._v(" "),n("h3",[e._v("多个特性的元素")]),e._v(" "),n("p",[e._v("多个特性的元素应该分多行撰写，每个特性一行。\n在 JavaScript 中，用多行分隔对象的多个属性是很常见的最佳实践，因为这样更易读。模板和 JSX 值得我们做相同的考虑。")]),e._v(" "),n("p",[e._v("例子:")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('<img\n  src="https://vuejs.org/images/logo.png"\n  alt="Vue Logo"\n>\n<MyComponent\n  foo="a"\n  bar="b"\n  baz="c"\n/>\n')])]),e._v(" "),n("h3",[e._v("模版中简单的表达式")]),e._v(" "),n("p",[e._v("多个特性的元素应该分多行撰写，每个特性一行。\n组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法")]),e._v(" "),n("p",[e._v("例子:")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("    \x3c!-- 在模板中 --\x3e\n    {{ normalizedFullName }}\n    // 复杂表达式已经移入一个计算属性\n    computed: {\n        normalizedFullName: function () {\n            return this.fullName.split(' ').map(function (word) {\n                return word[0].toUpperCase() + word.slice(1)\n            }).join(' ')\n        }\n    }\n")])]),e._v(" "),n("h3",[e._v("简单的计算属性")]),e._v(" "),n("p",[e._v("应该把复杂计算属性分割为尽可能多的更简单的属性。")]),e._v(" "),n("p",[e._v("例子:")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("computed: {\n  basePrice: function () {\n    return this.manufactureCost / (1 - this.profitMargin)\n  },\n  discount: function () {\n    return this.basePrice * (this.discountPercent || 0)\n  },\n  finalPrice: function () {\n    return this.basePrice - this.discount\n  }\n}\n")])]),e._v(" "),n("h3",[e._v("带引号的特性值")]),e._v(" "),n("p",[e._v("非空 HTML 特性值应该始终带引号 (单引号或双引号，选你 JS 里不用的那个)。\n在 HTML 中不带空格的特性值是可以没有引号的，但这样做常常导致带空格的特征值被回避，导致其可读性变差。")]),e._v(" "),n("p",[e._v("例子:")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('<input type="text">\n<AppSidebar :style="{ width: sidebarWidth + \'px\' }">\n')])]),e._v(" "),n("h3",[e._v("指令缩写")]),e._v(" "),n("p",[e._v("指令缩写 (用 : 表示 v-bind: 和用 "),n("strong",[e._v("at")]),e._v(" 表示 v-on:) 应该要么都用要么都不用。")]),e._v(" "),n("p",[e._v("例子:")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('<input\n  :value="newTodoText"\n  :placeholder="newTodoInstructions"\n>\n<input\n  v-bind:value="newTodoText"\n  v-bind:placeholder="newTodoInstructions"\n>\n<input\n  @input="onInput"\n  @focus="onFocus"\n>\n<input\n  v-on:input="onInput"\n  v-on:focus="onFocus"\n>\n')])]),e._v(" "),n("h3",[e._v("组件／实例的选项的顺序")]),e._v(" "),n("p",[e._v("组件/实例的选项应该有统一的顺序。\n这是我们推荐的组件选项默认顺序。它们被划分为几大类，所以你也能知道从插件里添加的新属性应该放到哪里。")]),e._v(" "),n("ol",[n("li",[n("p",[e._v("副作用 (触发组件外的影响)")]),e._v(" "),n("ul",[n("li",[e._v("el")])])]),e._v(" "),n("li",[n("p",[e._v("全局感知 (要求组件以外的知识)")]),e._v(" "),n("ul",[n("li",[e._v("name")]),e._v(" "),n("li",[e._v("parent")])])]),e._v(" "),n("li",[n("p",[e._v("组件类型 (更改组件的类型)")]),e._v(" "),n("ul",[n("li",[e._v("functional")])])]),e._v(" "),n("li",[n("p",[e._v("模板修改器 (改变模板的编译方式)")]),e._v(" "),n("ul",[n("li",[e._v("delimiters")]),e._v(" "),n("li",[e._v("comments")])])]),e._v(" "),n("li",[n("p",[e._v("模板依赖 (模板内使用的资源)")]),e._v(" "),n("ul",[n("li",[e._v("components")]),e._v(" "),n("li",[e._v("directives")]),e._v(" "),n("li",[e._v("filters")])])]),e._v(" "),n("li",[n("p",[e._v("组合 (向选项里合并属性)")]),e._v(" "),n("ul",[n("li",[e._v("extends")]),e._v(" "),n("li",[e._v("mixins")])])]),e._v(" "),n("li",[n("p",[e._v("接口 (组件的接口)")]),e._v(" "),n("ul",[n("li",[e._v("inheritAttrs")]),e._v(" "),n("li",[e._v("model")]),e._v(" "),n("li",[e._v("props/propsData")])])]),e._v(" "),n("li",[n("p",[e._v("本地状态 (本地的响应式属性)")]),e._v(" "),n("ul",[n("li",[e._v("data")]),e._v(" "),n("li",[e._v("computed")])])]),e._v(" "),n("li",[n("p",[e._v("事件 (通过响应式事件触发的回调)")]),e._v(" "),n("ul",[n("li",[e._v("watch")]),e._v(" "),n("li",[e._v("生命周期钩子 (按照它们被调用的顺序)")])])]),e._v(" "),n("li",[n("p",[e._v("非响应式的属性 (不依赖响应系统的实例属性)")]),e._v(" "),n("ul",[n("li",[e._v("methods")])])]),e._v(" "),n("li",[n("p",[e._v("渲染 (组件输出的声明式描述)")]),e._v(" "),n("ul",[n("li",[e._v("template/render")]),e._v(" "),n("li",[e._v("renderError")])])])]),e._v(" "),n("h3",[e._v("元素特性的顺序")]),e._v(" "),n("p",[e._v("元素 (包括组件) 的特性应该有统一的顺序。\n这是我们为组件选项推荐的默认顺序。它们被划分为几大类，所以你也能知道新添加的自定义特性和指令应该放到哪里。")]),e._v(" "),n("ol",[n("li",[n("p",[e._v("定义 (提供组件的选项)")]),e._v(" "),n("ul",[n("li",[e._v("is")])])]),e._v(" "),n("li",[n("p",[e._v("列表渲染 (创建多个变化的相同元素)")]),e._v(" "),n("ul",[n("li",[e._v("v-for")])])]),e._v(" "),n("li",[n("p",[e._v("条件渲染 (元素是否渲染/显示)")]),e._v(" "),n("ul",[n("li",[e._v("v-if")]),e._v(" "),n("li",[e._v("v-else-if")]),e._v(" "),n("li",[e._v("v-else")]),e._v(" "),n("li",[e._v("v-show")]),e._v(" "),n("li",[e._v("v-cloak")])])]),e._v(" "),n("li",[n("p",[e._v("渲染方式 (改变元素的渲染方式)")]),e._v(" "),n("ul",[n("li",[e._v("v-pre")]),e._v(" "),n("li",[e._v("v-once")])])]),e._v(" "),n("li",[n("p",[e._v("全局感知 (需要超越组件的知识)")]),e._v(" "),n("ul",[n("li",[e._v("id")])])]),e._v(" "),n("li",[n("p",[e._v("唯一的特性 (需要唯一值的特性)")]),e._v(" "),n("ul",[n("li",[e._v("ref")]),e._v(" "),n("li",[e._v("key")]),e._v(" "),n("li",[e._v("slot")])])]),e._v(" "),n("li",[n("p",[e._v("双向绑定 (把绑定和事件结合起来)")]),e._v(" "),n("ul",[n("li",[e._v("v-model")])])]),e._v(" "),n("li",[n("p",[e._v("其它特性 (所有普通的绑定或未绑定的特性)")])]),e._v(" "),n("li",[n("p",[e._v("事件 (组件事件监听器)")]),e._v(" "),n("ul",[n("li",[e._v("v-on")])])]),e._v(" "),n("li",[n("p",[e._v("内容 (复写元素的内容)")]),e._v(" "),n("ul",[n("li",[e._v("v-html")]),e._v(" "),n("li",[e._v("v-text")])])])]),e._v(" "),n("h3",[e._v("单文件组件的顶级元素的顺序")]),e._v(" "),n("p",[e._v("单文件组件应该总是让 < script >、< template > 和 < style > 标签的顺序保持一致。且< style > 要放在最后，因为另外两个标签至少要有一个。\n例子")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("   \x3c!-- ComponentA.vue --\x3e\n   <script>/* ... */<\/script>\n   <template>...</template>\n   <style>/* ... */</style>\n\n   \x3c!-- ComponentB.vue --\x3e\n   <script>/* ... */<\/script>\n   <template>...</template>\n   <style>/* ... */</style>\n")])]),e._v(" "),n("h3",[e._v("隐性的父子组件通信")]),e._v(" "),n("p",[e._v("应该优先通过 prop 和事件进行父子组件之间的通信，而不是 this.$parent 或改变 prop。\n一个理想的 Vue 应用是 prop 向下传递，事件向上传递的。遵循这一约定会让你的组件更易于理解。然而，在一些边界情况下 prop 的变更或 this.$parent 能够简化两个深度耦合的组件。\n问题在于，这种做法在很多简单的场景下可能会更方便。但请当心，不要为了一时方便 (少写代码) 而牺牲数据流向的简洁性 (易于理解)。")]),e._v(" "),n("p",[e._v("例子")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("Vue.component('TodoItem', {\n  props: {\n    todo: {\n      type: Object,\n      required: true\n    }\n  },\n  template: `\n    <input\n      :value=\"todo.text\"\n      @input=\"$emit('input', $event.target.value)\"\n    >\n  `\n})\nVue.component('TodoItem', {\n  props: {\n    todo: {\n      type: Object,\n      required: true\n    }\n  },\n  template: `\n    <span>\n      {{ todo.text }}\n      <button @click=\"$emit('delete')\">\n        X\n      </button>\n    </span>\n  `\n})\n")])]),e._v(" "),n("h3",[e._v("非flux的全局状态管理")]),e._v(" "),n("p",[e._v("应该优先通过 Vuex 管理全局状态，而不是通过 this.$root 或一个全局事件总线。\n通过 this.$root 和/或全局事件总线管理状态在很多简单的情况下都是很方便的，但是并不适用于绝大多数的应用。Vuex 提供的不仅是一个管理状态的中心区域，还是组织、追踪和调试状态变更的好工具。\n例子")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("\t   // store/modules/todos.js\n\t   export default {\n \t    state: {\n \t      list: []\n \t    },\n \t    mutations: {\n \t      REMOVE_TODO (state, todoId) {\n  \t       state.list = state.list.filter(todo => todo.id !== todoId)\n  \t     }\n \t    },\n \t    actions: {\n  \t     removeTodo ({ commit, state }, todo) {\n  \t       commit('REMOVE_TODO', todo.id)\n  \t     }\n \t    }\n\t   }\n\t   \x3c!-- TodoItem.vue --\x3e\n\t   <template>\n \t    <span>\n  \t     {{ todo.text }}\n   \t    <button @click=\"removeTodo(todo)\">\n   \t      X\n    \t   </button>\n  \t   </span>\n\t   </template>\n\n\t   <script>\n\t   import { mapActions } from 'vuex'\n\t   \n\t   export default {\n \t    props: {\n  \t     todo: {\n  \t       type: Object,\n  \t       required: true\n   \t    }\n \t    },\n \t    methods: mapActions(['removeTodo'])\n\t   }\n\t   <\/script>\n\n")])]),e._v(" "),n("h3",[e._v("组件内部名称")]),e._v(" "),n("p",[e._v("区分props 属性 和data属性\n变量名采用变量名采用 下划线 _ 连接单词的方式 不能使用$和_开头 以 _ 或 $ 开头的属性 不会 被 Vue 实例代理，因为它们可能和 Vue 内置的属性、API 方法冲突。你可以使用例如 vm.$data._property 的方式访问这些属性。\n区分props 属性 和data属性\n计算属性和methods方法使用驼峰规则")]),e._v(" "),n("h3",[e._v("method 自定义方法命名")]),e._v(" "),n("p",[e._v("动宾短语（good：jumpPage、openCarInfoDialog）\n（bad：go、nextPage、show、open、login）\n \najax 方法以 get、post 开头，以 data 结尾\n（good：getListData、postFormData）\n（bad：takeData、confirmData、getList、postForm）\n \n事件方法以 on 开头（onTypeChange、onUsernameInput）")]),e._v(" "),n("p",[e._v("init、refresh 单词除外")]),e._v(" "),n("p",[e._v("尽量使用常用单词开头（set、get、open、close、jump）")]),e._v(" "),n("p",[e._v("驼峰命名（good: getListData）（bad: get_list_data、getlistData)")]),e._v(" "),n("p",[e._v("用对时态和语态")]),e._v(" "),n("p",[e._v("注意单复数")]),e._v(" "),n("p",[e._v("准确用词\n正确拼写")]),e._v(" "),n("h3",[e._v("参考文献")]),e._v(" "),n("h4",[e._v("从达标到卓越 —— API 设计之道")]),e._v(" "),n("p",[n("a",{attrs:{href:"http://taobaofed.org/blog/2017/02/16/a-guide-to-api-design/"}},[e._v("http://taobaofed.org/blog/2017/02/16/a-guide-to-api-design/")])]),e._v(" "),n("h4",[e._v("vue风格指南")]),e._v(" "),n("p",[n("a",{attrs:{href:"https://cn.vuejs.org/v2/style-guide/"}},[e._v("https://cn.vuejs.org/v2/style-guide/")])])])}],o={render:v,staticRenderFns:_},r=o,s=n("/Xao"),p=s(null,r,!1,null,null,null);t.default=p.exports},Wrms:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var v=function(){var e=this,t=e.$createElement;e._self._c;return e._m(0,!1,!1)},_=[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("section",[n("ul",[n("li",[n("a",{attrs:{href:"#unit_az"}},[e._v("安装")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#unit_yr"}},[e._v("引入")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#unit_sy"}},[e._v("使用")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#unit_qtly"}},[e._v("嵌套路由（子路由）")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#unit_mmst"}},[e._v("命名视图（视图拆分）")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#unit_qt"}},[e._v("其它")])])]),e._v(" "),n("hr"),e._v(" "),n("h3",[n("a",{attrs:{name:"unit_az"}}),e._v("安装")]),e._v(" "),n("h5",[e._v("在命令行输入")]),e._v(" "),n("blockquote",[n("p",[e._v("npm install vue-router --save")])]),e._v(" "),n("h5",[e._v("在pack.json文件中会生成对应的依赖项，安装完成。")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('"dependencies": {\n    "vue": "^2.5.2",\n    "vue-router": "^3.0.1"\n},\n')])]),e._v(" "),n("h3",[n("a",{attrs:{name:"unit_yr"}}),e._v("引入")]),e._v(" "),n("ul",[n("li",[e._v("在入口文件中引入, 并注册使用")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v(" import vueRouter from 'vue-router'\n\n // 注册使用\n Vue.use(VueRouter)\n")])]),e._v(" "),n("h3",[n("a",{attrs:{name:"unit_sy"}}),e._v("使用")]),e._v(" "),n("ul",[n("li",[e._v("1 进行配置")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v(" // 设置\n let router = new VueRouter({\n     routes: [\n         {\n             path: '/path1',\n             component: youComponent\n         },\n         {\n             path: '/path2',\n             component: youComponent\n         }\n     ]\n })\n\n //引入到项目中\n new Vue({\n   el: '#app',\n   //加入项目中\n   // router:router,\n   router,\n   components: { App },\n   template: '<App/>'\n })\n")])]),e._v(" "),n("ul",[n("li",[e._v("2 在页面中设置渲染视图")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('   \x3c!-- 使用 router-link 组件来导航. --\x3e\n   \x3c!-- 通过传入 to 属性指定链接. --\x3e\n   \x3c!-- <router-link> 默认会被渲染成一个 <a> 标签 --\x3e\n   <router-link to="/path1">Go to A</router-link>\n   <router-link to="/path2">Go to B</router-link>\n\n   \x3c!-- 路由出口 --\x3e\n   \x3c!-- 路由匹配到的组件将渲染在这里 --\x3e\n   <router-view></router-view>\n')])]),e._v(" "),n("h3",[n("a",{attrs:{name:"unit_qtly"}}),e._v("嵌套路由（子路由）")]),e._v(" "),n("ul",[n("li",[e._v("1 在router对象中设置子路由")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("let router = new VueRouter({\n    routes: [\n        {\n            path: '/parent',\n            component: PageA,\n            // 子路由\n            children: [\n                {\n                    path: 'son',\n                    component: Children\n                }\n            ]\n        }\n    ]\n})\n")])]),e._v(" "),n("ul",[n("li",[e._v("2 在父组件中设置导航和视图")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('    <template>\n        <div>\n            \x3c!-- 使用 router-link 组件来导航. --\x3e\n            \x3c!-- 通过传入 to 属性指定链接. --\x3e\n            <router-link to="/parent/son">go to son</router-link>\n            \x3c!-- 路由匹配到的组件将渲染在这里 --\x3e\n            <router-view></router-view>\n        </div>\n    </template>\n')])]),e._v(" "),n("h3",[n("a",{attrs:{name:"mmst"}}),e._v("命名视图")]),e._v(" "),n("ul",[n("li",[e._v("1 在router对象中的设置")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("let router = new VueRouter({\n    routes: [\n        {\n            path: 'path1',\n            // 注：单个组件用component，包含对象用components\n            components: {\n                // 渲染到名为viewA的router-view上\n                viewA: Header\n                viewB: Body\n            }\n        }\n    ]\n})\n")])]),e._v(" "),n("ul",[n("li",[e._v("2 在组件中对router-view设置nmae")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('<template>\n    <div>\n        <router-view name="viewA"></router-view>\n        <router-view name="viewB"></router-view>\n    </div>\n</template>\n')])]),e._v(" "),n("h3",[n("a",{attrs:{name:"unit_qt"}}),e._v("其它")]),e._v(" "),n("ul",[n("li",[e._v("编程式导航")])]),e._v(" "),n("h5",[e._v("想要导航到不同的 URL，则使用 router.push 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。")]),e._v(" "),n("h5",[e._v('当你点击 <router-link> 时，这个方法会在内部调用，所以说，点击 <router-link :to="..."> 等同于调用 router.push(...)')]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("    // 字符串\n    router.push('home')\n\n    // 对象\n    router.push({ path: 'home' })\n\n    // 命名的路由\n    router.push({ name: 'user', params: { userId: 123 }})\n\n    // 带查询参数，变成 /register?plan=private\n    router.push({ path: 'register', query: { plan: 'private' }})\n")])]),e._v(" "),n("ul",[n("li",[e._v("重定向")])]),e._v(" "),n("h5",[e._v("访问a会重定向跳到b")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("const router = new VueRouter({\n  routes: [\n    { path: '/a', redirect: '/b'}\n  ]\n})\n")])]),e._v(" "),n("ul",[n("li",[e._v("别名")])]),e._v(" "),n("h5",[e._v("访问/b时，url会保持/b，但路由匹配为/a，并渲染/a视图")]),e._v(" "),n("h5",[e._v("让你可以自由地将 UI 结构映射到任意的 URL，而不是受限于配置的嵌套路由结构")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("const router = new VueRouter({\n  routes: [\n    { path: '/a', component: A, alias: '/b' }\n  ]\n})\n")])])])}],o={render:v,staticRenderFns:_},r=o,s=n("/Xao"),p=s(null,r,!1,null,null,null);t.default=p.exports},Xrl2:function(e,t,n){e.exports=n("0SRW")},dH06:function(e,t,n){e.exports=n("0ATw")},eCTH:function(e,t,n){e.exports=n("T5Ww")},h969:function(e,t,n){e.exports=n.p+"static/img/eslint.error.2d686b0.png"},hvSg:function(e,t,n){e.exports=n("FloJ")},kFLp:function(e,t,n){e.exports=n("lyxU")},lyxU:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var v=function(){var e=this,t=e.$createElement;e._self._c;return e._m(0,!1,!1)},_=[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("section",[n("h1",[e._v("迅策大前端优化系列--CSS使用规范")]),e._v(" "),n("p",[e._v("标签（空格分隔）： css bem sass")]),e._v(" "),n("hr"),e._v(" "),n("h3",[e._v("当我在寻找一个出色的 CSS 架构时我究竟在找什么")]),e._v(" "),n("ul",[n("li",[n("code",{pre:!0},[e._v("class")]),e._v(" 必须 "),n("strong",[e._v("尽可能的少")]),e._v("；")]),e._v(" "),n("li",[e._v("当我要查找 "),n("code",{pre:!0},[e._v("class")]),e._v(" 时 "),n("strong",[e._v("必须立即")]),e._v(" 可以知道 "),n("strong",[e._v("它放在整个项目的哪个位置")]),e._v("；")]),e._v(" "),n("li",[e._v("我 "),n("strong",[e._v("必须立即")]),e._v(" 知道当 "),n("strong",[e._v("编辑更改")]),e._v(" 这个 "),n("code",{pre:!0},[e._v("class")]),e._v(" 时 "),n("strong",[e._v("是否安全")]),e._v("；")])]),e._v(" "),n("h3",[e._v("什么是BEM")]),e._v(" "),n("p",[e._v("BEM拆分开 就是 "),n("code",{pre:!0},[e._v("Block")]),e._v(" "),n("code",{pre:!0},[e._v("Element")]),e._v(" "),n("code",{pre:!0},[e._v("Modifier")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v(".block { /* styles */ } \n.block__element { /* styles */ } \n.block--modifier { /* styles */ }\n")])]),e._v(" "),n("h3",[e._v("块(Block)")]),e._v(" "),n("p",[e._v("一个块就是一个组件。")]),e._v(" "),n("p",[e._v("按钮很好地阐释了可以包含不同样式的块。如果将 "),n("code",{pre:!0},[e._v("<button>")]),e._v(" 元素的背景颜色设置为红色，则所有 "),n("code",{pre:!0},[e._v("<buttons>")]),e._v(" 都将被强制继承红色背景。接下来，你必须通过覆盖你的 "),n("code",{pre:!0},[e._v("<button>")]),e._v(" 元素来修复代码（并且可能会在修复中“伤及无辜” ）。")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":"",class:"language-css"}},[n("span",{attrs:{class:"hljs-selector-tag"}},[e._v("button")]),e._v(" { \n    "),n("span",{attrs:{class:"hljs-attribute"}},[e._v("background-color")]),e._v(": red; \n} \n"),n("span",{attrs:{class:"hljs-selector-class"}},[e._v(".something")]),e._v(" "),n("span",{attrs:{class:"hljs-selector-tag"}},[e._v("button")]),e._v(" { \n    "),n("span",{attrs:{class:"hljs-attribute"}},[e._v("background-color")]),e._v(": blue; \n}\n")])]),e._v(" "),n("p",[e._v("如果设置了一个 "),n("code",{pre:!0},[e._v(".button")]),e._v(" 类的按钮，则可以在任何 "),n("code",{pre:!0},[e._v("<button>")]),e._v(" 元素上选择是否使用 "),n("code",{pre:!0},[e._v(".button")]),e._v(" 类。那么，如果你需要一个不同的背景颜色，你所做的就是改成一个新的 "),n("code",{pre:!0},[e._v("class")]),e._v("，比如说 "),n("code",{pre:!0},[e._v(".button--success")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v(".button { \n    background-color: red; \n} \n.button--success { \n    background-color: blue; \n}\n")])]),e._v(" "),n("p",[e._v("这部分也正是引入了BEM中的 "),n("code",{pre:!0},[e._v("修饰符--Modifier")])]),e._v(" "),n("h3",[e._v("修饰符(Modifier)")]),e._v(" "),n("p",[e._v("修饰符是改变某个块的外观的标志。要使用修饰符，可以将 "),n("code",{pre:!0},[e._v("--modifier")]),e._v(" 添加到块中。")]),e._v(" "),n("p",[e._v("从上面的按钮示例继续，修改的按钮将被命名为 "),n("code",{pre:!0},[e._v(".button--success")]),e._v("。")]),e._v(" "),n("p",[e._v("在传统的 BEM 中，当你使用修饰符时，你应该 将块和修饰符添加 到 HTML 中，以便在新的 "),n("code",{pre:!0},[e._v(".button--success")]),e._v(" 中不重写 "),n("code",{pre:!0},[e._v(".button")]),e._v(" 样式。")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('<button class="button">default button</button> \n<button class="button button--success">success button</button> \n\n<style>\n.button { \n    padding: 10px 20px;\n    background-color: red; \n} \n.button--success { \n    background-color: blue; \n}\n</style>\n')])]),e._v(" "),n("p",[e._v("因为在 "),n("code",{pre:!0},[e._v(".button")]),e._v(" 中已经声明了 "),n("code",{pre:!0},[e._v("padding")]),e._v(" , 所以我们无需在 "),n("code",{pre:!0},[e._v(".button--success")]),e._v(" 中重新声明。")]),e._v(" "),n("p",[e._v("那么，还有没有 "),n("strong",[e._v("更加理想")]),e._v(" 的写法呢？")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('<button class="button">default button</button> \n<button class="button--success">success button</button>\n')])]),e._v(" "),n("p",[e._v("不幸的是，如果 HTML 中没有 .button，我们必须回到非简洁的 CSS：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v(".button { \n    padding: 10px 20px;\n    background-color: red; \n} \n.button--success { \n    padding: 10px 20px;\n    background-color: blue; \n}\n")])]),e._v(" "),n("p",[e._v("有两种方法可以编写简洁的 CSS，而不需要额外的 "),n("code",{pre:!0},[e._v("class")]),e._v("！")]),e._v(" "),n("h4",[e._v("方法 1：使用 mixin")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("注意：因为我平时都是用sass编写css，所以此方式也是通过sass的方式去实现。\n")])]),e._v(" "),n("p",[e._v("在我们的按钮示例中，我们只需要将 padding 写入 mixin。 在这里，我在块中调用这个 mixin：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("@mixin button {\n    padding: 10px 20px;\n}\n.button {\n    @include button;\n    background-color: red; \n}\n.button--success { \n    @include button;\n    background-color: blue; \n}\n")])]),e._v(" "),n("h4",[e._v("方法 2：使用 CSS 属性选择器")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("[class*='button']:not([class*='button__']) {\n    padding: 10px 20px;\n}\n")])]),e._v(" "),n("p",[e._v("第一部分（  "),n("code",{pre:!0},[e._v("[class*='button']")]),e._v(" ）告诉解析器查找包含文本 button 的所有 class。\n第二部分（ "),n("code",{pre:!0},[e._v(":not([class*='button__'])")]),e._v(" ）告诉解析器将包含.button__任何东西排除在外，于是排除了 BEM 元素。")]),e._v(" "),n("p",[e._v("我们来看看 BEM 的第三个重要部分 —— 元素。")]),e._v(" "),n("h3",[e._v("元素(Element)")]),e._v(" "),n("p",[e._v("元素是块的子节点。为了表明某个东西是一个元素，你需要在块名后添加 "),n("code",{pre:!0},[e._v("__element")]),e._v("。")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('<div class="xc-dailog">\n    <div class="xc-dialog__header"></div>\n    <div class="xc-dialog__body"></div>\n    <div class="xc-dialog__footer"></div>\n</div>\n')])]),e._v(" "),n("p",[e._v("BEM 元素有两个优点 ：")]),e._v(" "),n("ul",[n("li",[e._v("可以让 CSS 的优先级保持相对扁平。")]),e._v(" "),n("li",[e._v("能立即知道哪些东西是一个子元素。")])]),e._v(" "),n("blockquote",[n("p",[e._v("注意：永远不应该链式命名 BEM 元素，禁止类似 "),n("code",{pre:!0},[e._v(".dailog__header__title")]),e._v("的命名。")])]),e._v(" "),n("p",[e._v("有两种方法可以绕过长长的 BEM 链式命名：")]),e._v(" "),n("ul",[n("li",[e._v("只把子子元素链接到有意义的块。")]),e._v(" "),n("li",[e._v("创建新的块来保存元素。")])]),e._v(" "),n("h4",[e._v("链接孙元素到块")]),e._v(" "),n("p",[e._v("接下来是一个例子。在下面的代码中，你将看到 "),n("code",{pre:!0},[e._v(".article__header")]),e._v(" 是 "),n("code",{pre:!0},[e._v(".article")]),e._v(" 的子元素。"),n("code",{pre:!0},[e._v(".article__title")]),e._v(" 是 "),n("code",{pre:!0},[e._v("article")]),e._v(" 的孙元素（或者说是 "),n("code",{pre:!0},[e._v(".article__header")]),e._v(" 的子元素，如果你将它们同时表示为 "),n("code",{pre:!0},[e._v(".article")]),e._v(" 的子元素，就没有冲突，因为这个表单同时只有他们存在。")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('<article class="article"> \n    <header class="article__header"> \n        <h1 class="article__title"></h1> \n    </header> \n</article>\n')])]),e._v(" "),n("p",[e._v("虽然这样有效，你也会遇到无意义的链接孙元素的情况。举个例子：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('<section class="comments"> \n    <h2 class="comments__title"></h2> \n    <article class="comments__comment"> \n        <h3 class="comments__comment-title"></h3> \n    </article> \n    <article class="comments__comment"> \n        <h3 class="comments__comment-title"></h3> \n    </article>\n</section>\n')])]),e._v(" "),n("p",[e._v("此时我们需要创建新块来保存孙元素。")]),e._v(" "),n("h4",[e._v("创建新的块来保存孙元素")]),e._v(" "),n("p",[e._v("这时，我们可以把 "),n("code",{pre:!0},[e._v(".comments__comment")]),e._v(" 拆为 "),n("code",{pre:!0},[e._v(".comments")]),e._v(" 和 "),n("code",{pre:!0},[e._v(".comment")]),e._v(" ：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('<section class="comments"> \n    <h2 class="comments__title"></h2> \n    <article class="comment"> \n        <h3 class="comment-title"></h3> \n    </article> \n    <article class="comment"> \n        <h3 class="comment-title"></h3> \n    </article>\n</section>\n')])]),e._v(" "),n("blockquote",[n("p",[e._v("注意：请确保将 "),n("code",{pre:!0},[e._v(".comments")]),e._v(" 和 "),n("code",{pre:!0},[e._v(".comment")]),e._v("块放在同一个文件中，以方便参考。")])]),e._v(" "),n("p",[e._v("不幸的是，有时候它不像 "),n("code",{pre:!0},[e._v(".comments__comment")]),e._v(" 那么简单。例如，假设在块中有一个列表元素。")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('<div class="block"> \n    <h3 class="block__title"></h3> \n    <ul class="block__list"> \n        <li class="block__item"> \n            \x3c!-- class name? --\x3e \n            <h3 class="???????"></h3> \n        </li> \n    </ul> \n</div>\n')])]),e._v(" "),n("p",[e._v("如果你注意到，我已经链接了"),n("code",{pre:!0},[e._v(".block__item")]),e._v(" ，这是一个 "),n("code",{pre:!0},[e._v(".block")]),e._v(" 的孙元素。 将 "),n("code",{pre:!0},[e._v(".block__item")]),e._v(" 中的元素链接到 "),n("code",{pre:!0},[e._v(".block")]),e._v(" 没有意义，或可能最终会遇到一些糟糕的局面。")]),e._v(" "),n("p",[e._v("然而，同时由于它们被一起使用，所以为 "),n("code",{pre:!0},[e._v(".block__list")]),e._v(" 或 "),n("code",{pre:!0},[e._v(".block__item")]),e._v(" 创建一个新的块是没有意义的 。你会命名什么来保持在上下文中有意义？")]),e._v(" "),n("p",[e._v("在这种情况下，我一般会为 "),n("code",{pre:!0},[e._v("block__item")]),e._v(" 创建一个名为 "),n("code",{pre:!0},[e._v(".item")]),e._v(" 的伪块。看下面的"),n("code",{pre:!0},[e._v("HTML")]),e._v("。")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('<div class="block"> \n    <h3 class="block__title"></h3> \n    <ul class="block__list"> \n        <li class="block__item"> \n            <h3 class="item__title"></h3> \n        </li> \n    </ul> \n</div>\n')])]),e._v(" "),n("h3",[e._v("命名空间由来")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('<nav class="main-nav"> \n    <a href="#">Home</a> \n    <button class="button">Menu</button> \n</nav>\n')])]),e._v(" "),n("p",[e._v("现在，有两个区块。 一个叫 "),n("code",{pre:!0},[e._v(".main-nav")]),e._v(" ，另一个叫 "),n("code",{pre:!0},[e._v(".button")]),e._v(" 。 "),n("code",{pre:!0},[e._v(".button")]),e._v(" 存在于 "),n("code",{pre:!0},[e._v(".main-nav")]),e._v(" 内。")]),e._v(" "),n("p",[e._v("现在需求需要我们把这个 "),n("code",{pre:!0},[e._v("button")]),e._v(" 的颜色从 "),n("code",{pre:!0},[e._v("blue")]),e._v(" 变成 "),n("code",{pre:!0},[e._v("green")]),e._v(" 。同时你也想给 "),n("code",{pre:!0},[e._v(".button")]),e._v(" 加些左边距来和 "),n("code",{pre:!0},[e._v("home")]),e._v(" 链接分开。")]),e._v(" "),n("p",[e._v("那么问题来了，我们应该怎样书写CSS代码呢？这下面有几种可能的答案：")]),e._v(" "),n("ul",[n("li",[e._v("给 "),n("code",{pre:!0},[e._v(".main-nav .button")]),e._v(" 添加 "),n("code",{pre:!0},[e._v("margin")]),e._v(" 和 "),n("code",{pre:!0},[e._v("background-color")])]),e._v(" "),n("li",[e._v("给 "),n("code",{pre:!0},[e._v("button--modifier")]),e._v(" 添加 "),n("code",{pre:!0},[e._v("margin")]),e._v(" 和 "),n("code",{pre:!0},[e._v("background-color")])]),e._v(" "),n("li",[e._v("给 "),n("code",{pre:!0},[e._v(".main-nav .button")]),e._v(" 添加 "),n("code",{pre:!0},[e._v("margin")]),e._v(" ，给 "),n("code",{pre:!0},[e._v("button--modifier")]),e._v(" 添加 "),n("code",{pre:!0},[e._v("background-color")])]),e._v(" "),n("li",[e._v("给 "),n("code",{pre:!0},[e._v(".main-nav a")]),e._v(" 添加 "),n("code",{pre:!0},[e._v("margin")]),e._v(" ，给 "),n("code",{pre:!0},[e._v(".main-nav .button")]),e._v(" 添加 "),n("code",{pre:!0},[e._v("background-color")])]),e._v(" "),n("li",[e._v("给 "),n("code",{pre:!0},[e._v(".main-nav a")]),e._v(" 添加 "),n("code",{pre:!0},[e._v("margin")]),e._v("，给 "),n("code",{pre:!0},[e._v("button--modifier")]),e._v(" 添加 "),n("code",{pre:!0},[e._v("background-color")])])]),e._v(" "),n("p",[e._v("实现的方式很多种，如果我们只有BEM，当我们修改已写好的样式时，就不能立即知道此次修改是否安全。")]),e._v(" "),n("p",[e._v("因此我们要引入一套规范的BEM命名空间。")]),e._v(" "),n("h3",[e._v("命名空间规范")]),e._v(" "),n("ul",[n("li",[n("code",{pre:!0},[e._v(".l-")]),e._v(" : 布局(layouts)")]),e._v(" "),n("li",[n("code",{pre:!0},[e._v(".xc-")]),e._v(" : 通用组件(components)")]),e._v(" "),n("li",[n("code",{pre:!0},[e._v(".c-")]),e._v(" : 局部组件(components)")]),e._v(" "),n("li",[n("code",{pre:!0},[e._v(".o-")]),e._v(" : 局部对象(objects)")]),e._v(" "),n("li",[n("code",{pre:!0},[e._v(".is-")]),e._v(" | "),n("code",{pre:!0},[e._v(".has-")]),e._v(" : 状态类(state classes)")]),e._v(" "),n("li",[n("code",{pre:!0},[e._v(".t1")]),e._v(" | "),n("code",{pre:!0},[e._v(".s1")]),e._v(" : 排版大小(typography sizes)")]),e._v(" "),n("li",[n("code",{pre:!0},[e._v(".u-")]),e._v(" : 实用类(utility classes)")])]),e._v(" "),n("h4",[e._v("“.l-” —— 布局(layouts)")]),e._v(" "),n("h5",[e._v("全局布局")]),e._v(" "),n("p",[e._v("全局布局是应用于所有页面的布局。它们通常是在任何地方都使用的大型网格容器。 一个例子是.l-wrap 类：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v(".l-wrap { \n    padding-left: 10px; \n    padding-right: 10px; \n    @media (min-width: 1000px) { \n        max-width: 800px; \n        margin-left: auto; \n        margin-right: auto; \n    } \n}\n")])]),e._v(" "),n("p",[e._v("我们可以在每个地方都使用.l-wrap类，比如在header和footer里来对齐内容：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('<div class="site-header"> \n    <div class="l-wrap"> \n        \x3c!-- stuff --\x3e \n    </div> \n</div> \n<div class="site-footer">\n    <div class="l-wrap"> \n        \x3c!-- stuff --\x3e \n    </div> \n</div>\n')])]),e._v(" "),n("p",[e._v("由于这些class在全局使用，所以我们可以把它们写在 "),n("code",{pre:!0},[e._v("_layouts.scss")]),e._v(" 部分。")]),e._v(" "),n("h3",[e._v("“.o-”——对象(Objects)")]),e._v(" "),n("p",[e._v("对象物们都有着以下的属性：")]),e._v(" "),n("ul",[n("li",[e._v("它们的里面不能包含其他对象或组件")]),e._v(" "),n("li",[e._v("它们之于上下文是独立的")])]),e._v(" "),n("h3",[e._v("“.is-/.has-” ——状态类")]),e._v(" "),n("p",[e._v("状态类表示对象/组件的当前状态。当应用状态类时，我们可以立即知道对象/组件是否具有下拉 "),n("code",{pre:!0},[e._v(".has-dropdown")]),e._v(" 或当前处于打开状态 "),n("code",{pre:!0},[e._v(".is-open")]),e._v("。")]),e._v(" "),n("h3",[e._v("“.t”或“.s”——排版类(Typography)")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v(".t1 - 最大的字体大小。\n.t2 - 第二大字体大小。\n.t3 - 第三大字体大小。\n.s1 - 第一字体大小较小的基本字体大小。\n.s2 - 第二字体大小较小的基本字体大小。\n...\n")])]),e._v(" "),n("p",[e._v("排版类是对象的子集，这意味着我们不应该在排版类中添加  "),n("code",{pre:!0},[e._v("margin")]),e._v("或 "),n("code",{pre:!0},[e._v("padding")]),e._v("。而这些 "),n("code",{pre:!0},[e._v("margin")]),e._v(" 或 "),n("code",{pre:!0},[e._v("padding")]),e._v(" 应该直接添加到组件。")]),e._v(" "),n("h3",[e._v("“.u-” ——实用类(Utility)")]),e._v(" "),n("p",[e._v("实用类是用来表现样式的一个非常好的辅助类。因此，它们通常只包含一个属性，并且包含 "),n("code",{pre:!0},[e._v("!important")]),e._v(" 声明。")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v(".u-text-left { text-align: left !important; } \n.u-text-center { text-align: center !important; } \n.u-text-right { text-align: right !important; } \n.u-hide-st-med { @media (man-width: 599px) { display: none !important; } } \n.u-hide-bp-med { @media (min-width: 600px) { display: none !important; } }\n")])])])}],o={render:v,staticRenderFns:_},r=o,s=n("/Xao"),p=s(null,r,!1,null,null,null);t.default=p.exports},pPTn:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var v=function(){var e=this,t=e.$createElement;e._self._c;return e._m(0,!1,!1)},_=[function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("section",[v("h1",[e._v("eslint")]),e._v(" "),v("hr"),e._v(" "),v("h2",[e._v("关于")]),e._v(" "),v("p",[e._v("ESLint 是一个开源的 JavaScript 代码检查工具，由 Nicholas C. Zakas 于2013年6月创建。代码检查是一种静态的分析，常用于寻找有问题的模式或者代码，并且不依赖于具体的编码风格。对大多数编程语言来说都会有代码检查，一般来说编译程序会内置检查工具。")]),e._v(" "),v("p",[e._v("当开发人员数量不再限于三两个人时，一套统一的框架，编程思维，编程规范所节约的沟通成本是不需要多说的。更重要的是使用ESLint的过程中，我们能够接触到所有开发者所公认的代码规范，能够有机会学习并理解代码规范背后的原因。")]),e._v(" "),v("h2",[e._v("规则")]),e._v(" "),v("p",[e._v("ESLint的规则分为：")]),e._v(" "),v("ol",[v("li",[v("p",[e._v('"Possible Errors" // 可能导致错误')])]),e._v(" "),v("li",[v("p",[e._v('"Best Practices" // 最佳实践')])]),e._v(" "),v("li",[v("p",[e._v('"Strict Mode" // 严格模式相关')])]),e._v(" "),v("li",[v("p",[e._v('"Variables" // 变量定义相关')])]),e._v(" "),v("li",[v("p",[e._v('"Node.js and CommonJS" // node.js或者浏览器使用CommonJS')])]),e._v(" "),v("li",[v("p",[e._v('"Stylistic Issues" // 风格指南')])]),e._v(" "),v("li",[v("p",[e._v('"ECMAScript 6" // ES6，即ES2005相关')])])]),e._v(" "),v("p",[e._v("这些规则中，归纳出了一些推荐启用的规则，在文档中用绿色的勾标明出来；同样也有一部分规则是ESLint能够直接帮忙修改并修改的规则，这些规则通过特定字符串的修改即可，在文档中以黄色🔧符号表明出来。")]),e._v(" "),v("h2",[e._v("规则示例")]),e._v(" "),v("ol",[v("li",[v("p",[e._v('"no-cond-assign" 禁止在条件语句中出现赋值操作符\n在条件语句中，容易将一个比较运算符（像 ==）错写成赋值运算符（如 =）。\n为什么有这条规则？因为条件语句本身不应该处理赋值的事情，同时，如果在条件语句中不小心写成赋值操作符，定位问题会非常非常困难。')]),e._v(" "),v("pre",{pre:!0},[v("code",{attrs:{"v-pre":""}},[e._v(" // 找出数组中undefined的元素序号\n var arrA = [1,2,3,4,5,6,7,8,9,99];\n var funcA = function(arr){\n     for(let i = 0; i < arr.length; i++){\n       if(arr[i] = undefined){\n         console.log(i)\n       }\n     }    \n };\n funcA(arrA);\n")])]),e._v(" "),v("p",[e._v("上面这一段代码乍看没什么问题，arrA数组中没有undefined的元素，所以不会console出任何东西。但是，在funcA执行完之后，arrA就被修改成了"),v("code",{pre:!0},[e._v("[undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined]")]),e._v(";另外，当arrA是一个含有undefined元素的数组时（例如[1,2,3,undefined,5,6,7,8,9,99]），连结果都是错误的。")]),e._v(" "),v("p",[e._v("在接触到ESLint之前，我所知道的一个解决这个问题的办法有一个，那就是定一条编程规范，判断语句中，变量应该在等号后面，而将常量放在等号之前。例如上面的代码中，只需要修改为“if(undefined = arr[i])”就可以了。改成这样，至少在测试的时候马上就可以看出这个函数不符合预期，也不会错误改到arrA的值。")])]),e._v(" "),v("li",[v("p",[e._v('"no-constant-condition" 禁止在条件中使用常量表达式\n将一个常量表达式（比如，一个字面值）作为一个测试条件可能是个书写错误或者为了触发某个特定的行为。\n一般来说，既然我们需要使用条件语句，那么这个语句不应该总是为false，或者总是为true。')]),e._v(" "),v("pre",{pre:!0},[v("code",{attrs:{"v-pre":""}},[e._v(" // 下面的这段代码看起来就是还没有准备好发布的，判断条件恒为false也就必定不会执行内部处理。\n if (false) {\n     doSomethingUnfinished();\n }\n")])]),e._v(" "),v("p",[e._v("但是，在实际的代码中，存在这样的情况：永远需要执行的代码。例如服务器编程时有个永远执行的循环从套接字中获取数据，这样就能够处理网络上随时随地的请求了。\n在js中，像上面一样的永远执行的循环处理比较少见，但有构思一个队列机制，可以使用到永远执行的循环处理。前端队列算法，当getTimeout是一个回调处理函数时，可以采用以下代码处理。需要注意，forever函数内部，必须用“while (true)”而不能把内部的if判断条件提到while中。为什么请自行思考。")]),e._v(" "),v("pre",{pre:!0},[v("code",{attrs:{"v-pre":""}},[e._v(" var getTimeout = function(value){\n     setTimeout(function(){\n         console.log(value)\n         loading = false;\n         if(0 != arr.length){\n             doF();\n         }\n  \n     }, 1000* value)\n }\n\n var arr = [4,3,2,1];\n function* forever(){\n     while (true){\n         if(arr.length > 0){\n             let a = arr.shift();\n             yield getTimeout(a);\n         }else{\n             yield 0;\n         }\n  \n     }\n }\n var d = forever();\n var loading = false;\n\n var addF = function(value){\n     arr.push(value);\n     doF();\n };\n\n var doF = function(){\n     if(loading){\n         return;\n     }\n     loading = true;\n     var result = d.next();\n     console.log(result)\n     if(0 == result.value){\n         loading = false;\n     }\n }\n addF(2)\n")])])]),e._v(" "),v("li",[v("p",[e._v('"no-fallthrough" 禁止 case 语句落空\n在 JavaScript 中，switch 语句是一种比较容易出错的结构，在某种程度上这要归功于 case 的落空能力。')]),e._v(" "),v("pre",{pre:!0},[v("code",{attrs:{"v-pre":""}},[e._v(" switch(foo) {\n     case 1:\n         doSomething();\n\n     case 2:\n         doSomethingElse();\n }\n")])]),e._v(" "),v("p",[e._v("在上面这段代码中，foo为1时，执行doSomething()的同时还会执行doSomethingElse()；\n当然，可以用break来阻止这样的情况。此规则也是为了避免忘了写break的。")]),e._v(" "),v("p",[e._v("但是，当我们就是要像上面的代码一样，foo为1的情况下不要break呢？只需要在"),v("code",{pre:!0},[e._v("case 1")]),e._v("的底部加上“// falls through”即可。")])])]),e._v(" "),v("h2",[e._v("安装配置")]),e._v(" "),v("p",[e._v('下面是node环境的安装与配置。对于vue结尾的文件，我们还需要安装"eslint-config-vue"和"eslint-plugin-vue"插件。')]),e._v(" "),v("ol",[v("li",[v("p",[e._v("npm install eslint --save-dev")])]),e._v(" "),v("li",[v("p",[e._v("./node_modules/.bin/eslint --init")])]),e._v(" "),v("li",[v("p",[e._v("./node_modules/.bin/eslint yourfile.js")])])]),e._v(" "),v("p",[e._v("eslint同样支持编辑器集成。例如sublime，安装sublimeLinter，以及SublimeLinter-contrib-eslint 即可。")]),e._v(" "),v("h2",[e._v("sublime上效果")]),e._v(" "),v("p",[v("img",{attrs:{src:n("h969"),alt:"sublime上效果"}})])])}],o={render:v,staticRenderFns:_},r=o,s=n("/Xao"),p=s(null,r,!1,null,null,null);t.default=p.exports},phfM:function(e,t,n){function v(e){return n(_(e))}function _(e){var t=o[e];if(!(t+1))throw new Error("Cannot find module '"+e+"'.");return t}var o={"./articleB.md":"Xrl2","./bem.md":"kFLp","./checklist.md":"dH06","./eslint.md":"re7l","./h5menubar.md":"hvSg","./naming.md":"eCTH","./vue-router.md":"BE8U","./vuex.md":"9+yl"};v.keys=function(){return Object.keys(o)},v.resolve=_,e.exports=v,v.id="phfM"},re7l:function(e,t,n){e.exports=n("pPTn")}});
//# sourceMappingURL=1.fffb53ec04ce80ef6c04.js.map